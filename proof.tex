\section{Proof of Lemmas}
\label{sec:proof}

\begin{lemma}
\label{lem:okPreserved}
If \(\OK_n(P, C)\) and \( \langle P, C \rangle \xlongrightarrow{\rho} \langle P', C' \rangle\), then
\begin{itemize}
\item \(\OK_{n-1}(P', C')\) if \(\rho = \Malloc\),
\item \(\OK_{n+1}(P', C')\) if \(\rho = \Free\),
\item \(\OK_n(P', C')\) if \(\rho = \mbox{Otherwise}  \)
\end{itemize}
\end{lemma}

\begin{proof}
By induction on \(\langle P, C \rangle \xlongrightarrow{\rho} \langle P', C' \rangle \).

\begin{itemize}

\item Case \(P = {\bf 0};P'\) and \( \langle {\bf 0};P', C \rangle \rightarrow \langle P', C \rangle\)

  We need to prove \(\OK_n(P', C)\).  Assume that \(\OK_n(P', C)\)
  does not hold. Then, we have \( \exists \sigma \) and \(Q\) s.t. \(
  \langle P', C \rangle \xlongrightarrow{\sigma} \langle Q, C' \rangle
  \), \(\sharp_{m}(\sigma) - \sharp_{f}(\sigma) > n\).

  From the definition of that \(OK_n({\bf 0};P', C)\) holds, we have
  if \( \langle {\bf 0};P', C \rangle \rightarrow \langle P', C
  \rangle \xlongrightarrow{\sigma} \langle Q, C' \rangle \), then
  \(\sharp_m(\sigma) - \sharp_f(\sigma) \le n \), which are in
  contradiction to the assumption \(\sharp_{m}(\sigma) -
  \sharp_{f}(\sigma) > n\). Therefore, \(\OK_n(P', C)\) holds.

\item Case \(P = \Malloc\) and \( \langle \Malloc, C \rangle \xlongrightarrow{\Malloc} \langle
          0, C \rangle\)

  we need to prove \(OK_{n-1}(0, C)\), which means we need to prove
  that for all \(\sigma\) and \(Q\), if \(\langle 0, C \rangle
  \xlongrightarrow{\sigma} \langle Q, C'\rangle\) then
  \(\sharp_{m}(\sigma) - \sharp_{f}(\sigma) \le n - 1\). There is no
  \(\sigma\) and \(Q\) such that \(\langle 0, C \rangle
  \xlongrightarrow{\sigma} \langle Q, C'\rangle\). Therefore,
  \(OK_{n-1}(0, C)\) holds.

\item Case \(P = \Free\) and \(\langle \Free, C \rangle
  \xlongrightarrow{\Free} \langle {\bf 0}, C \rangle \)

  We need to prove \(\OK_{n+1}({\bf 0}, C)\), which means we need to
  prove \( \forall \sigma \) and \(Q\) if \( \langle {\bf 0}, C
  \rangle \xlongrightarrow{\sigma} \langle Q, C' \rangle \), then
  \(\sharp_{m}(\sigma) - \sharp_{f}(\sigma) \le n + 1\).  There is no
  \(Q\) and \(\sigma\) s.t. \(\langle {\bf 0}, C \rangle
  \xlongrightarrow{\sigma} \langle Q, C \rangle \), so (1)
  holds. Therefore, \(OK({\bf 0}, C)\) holds.

\item Case \(P = \Endconst\) and \(\frac {C' = filter(C, *x) }
  {\langle \Endconst, C \rangle \rightarrow \langle {\bf 0}, C' \rangle} \)

  We need to prove \(\OK_n({\bf 0}, C')\), which means we need to
  prove \( \forall \sigma \) and \(Q\) if \( \langle {\bf 0}, C
  \rangle \xlongrightarrow{\sigma} \langle Q, C' \rangle \), then
  \(\sharp_{m}(\sigma) - \sharp_{f}(\sigma) \le n\) and (2) \(
  OK(C')\) holds.  There is no \(Q\) and \(\sigma\) s.t. \(\langle
  {\bf 0}, C \rangle \xlongrightarrow{\sigma} \langle Q, C \rangle
  \). So \(\OK_n({\bf 0}, C')\) holds.

\item Case \(P = (x)P'\) and \(\frac {x' is fresh }
  {\langle (x)P', C \rangle \rightarrow \langle [x'/x]P', C \rangle} \)

  We need to prove \(\OK_n([x'/x]P', C)\). Assuming that
  \(\OK_n([x'/x]P', C)\) does not hold. Then we have \(\exists
  \sigma\) and \(Q\) s.t. \( \langle [x'/x]P', C \rangle
  \xlongrightarrow{\sigma} \langle Q, C' \rangle \) and
  \(\sharp_{m}(\sigma) - \sharp_{f}(\sigma) > n\).

  From the definition of \(\OK_n((x)P', C)\), we have if \( \langle
  (x)P', C \rangle \rightarrow \langle [x'/x]P', C \rangle
  \xlongrightarrow{\sigma} \langle Q, C' \rangle \), then
  \(\sharp_{m}(\sigma) - \sharp_{f}(\sigma) \le n\). Therefore we get
  the contradiction.

  Therefore \(\OK_n([x'/x]P', C)\) holds.
    
\item Case \( P = \Sirx(P_1,P_2) \) and \( \frac{ \scon\Sirx \notin C}
  { \langle \Sirx(P_1, P_2), C \rangle \xlongrightarrow{\snull} \langle P_1, C
    \rangle } \)

  We need to prove \(\OK_n(P_1, C)\).  Assume that \(\OK_n(P_1, C)\)
  does not hold. Then, we have \( \exists \sigma \) and \(Q\)
  s.t. \( \langle P_1, C \rangle \xlongrightarrow{\sigma} \langle Q,
  C' \rangle \) and \(\sharp_{m}(\sigma) -
  \sharp_{f}(\sigma) > n\).

  From the definition of that \(OK_n(\Sirx(P_1, P_2), C)\) holds, we
  have if \( \langle \Sirx(P_1, P_2), C \rangle
  \xlongrightarrow{\snull} \langle P_1, C \rangle
  \xlongrightarrow{\sigma} \langle Q, C' \rangle \) then
  \(\sharp_m(\sigma) - \sharp_f(\sigma) \le n \), which is in
  contradiction to the assumption \(\sharp_m(\sigma) -
  \sharp_f(\sigma) > n \).  Therefore, \(\OK_n(P_1, C)\) holds.

\item Case \( P = \Sirx(P_1,P_2) \) and \( \frac{ \scon\Sirx \notin C}
  { \langle \Sirx(P_1, P_2), C \rangle \rightarrow \langle P_2, C
    \rangle } \)

  We need to prove \(\OK_n(P_2, C)\).  Assume that \(\OK_n(P_2, C)\)
  does not hold. Then, we have \( \exists \sigma \) and \(Q\)
  s.t. \( \langle P_2, C \rangle \xlongrightarrow{\sigma} \langle Q,
  C' \rangle \) and \(\sharp_{m}(\sigma) -
  \sharp_{f}(\sigma) > n\).

  From the definition of that \(OK_n(\Sirx(P_1, P_2), C)\) holds, we
  have if \( \langle \Sirx(P_1, P_2), C \rangle \xlongrightarrow{\snnull}
  \langle P_2, C \rangle \xlongrightarrow{\sigma} \langle Q, C'
  \rangle \), then \(\sharp_m(\sigma) -
  \sharp_f(\sigma) \le n \), which is in
  contradiction to the assumption.  Therefore, \(\OK_n(P_2, C)\)
  holds.

\item Case \( P = \Sirx(P_1,P_2) \) and \( \frac{ \snull \in C
  \andalso \scon\Sirx \in C} { \langle \Sirx(P_1, P_2), C \rangle
  \rightarrow \langle P_1, C \rangle } \)

  We need to prove \(\OK_n(P_1, C)\).  Assume that \(\OK_n(P_1, C)\)
  does not hold. Then, we have \( \exists \sigma \) and \(Q\)
  s.t. \( \langle P_1, C \rangle \xlongrightarrow{\sigma} \langle Q,
  C' \rangle \) and \(\sharp_{m}(\sigma) -
  \sharp_{f}(\sigma) > n\).

  From the definition of that \(OK_n(\Sirx(P_1, P_2), C)\) holds, we
  have if \( \langle \Sirx(P_1, P_2), C \rangle \rightarrow
  \langle P_1, C \rangle \xlongrightarrow{\sigma} \langle Q, C'
  \rangle \), then \(\sharp_m(\sigma) -
  \sharp_f(\sigma) \le n \), which is in
  contradiction to the assumption.  Therefore, \(\OK_n(P_1, C)\)
  holds.

\item Case \( P = \Sirx(P_1,P_2) \) and \( \frac{ \snnull \in C
  \andalso \scon\Sirx \in C} { \langle \Sirx(P_1, P_2), C \rangle
  \rightarrow \langle P_2, C \rangle } \)

  We need to prove \(\OK_n(P_2, C)\).  Assume that \(\OK_n(P_2, C)\)
  does not hold. Then we have \( \exists \sigma \) and \(Q\)
  s.t. \( \langle P_2, C \rangle \xlongrightarrow{\sigma} \langle Q,
  C' \rangle \) and \(\sharp_{m}(\sigma) - \sharp_{f}(\sigma) > n\).

  From the definition of that \(OK_n(\Sirx(P_1, P_2), C)\) holds, we
  have if \( \langle \Sirx(P_1, P_2), C \rangle \rightarrow
  \langle P_2, C \rangle \xlongrightarrow{\sigma} \langle Q, C'
  \rangle \), then \(\sharp_m(\sigma) -
  \sharp_f(\sigma) \le n \), which is in
  contradiction to the assumption.  Therefore, \(\OK_n(P_2, C)\)
  holds.

 \item Case \( P = \Sirx(P_1,P_2) \) and \( \frac{ \snull,\snnull \notin C
  \andalso \scon\Sirx \in C} { \langle \Sirx(P_1, P_2), C \rangle
  \xlongrightarrow{\snull} \langle P_1, C\cup\{\snull\} \rangle } \)

  We need to prove \(\OK_n(P_1, C\cup\{\snull\})\).  Assume that
  \(\OK_n(P_1, C\cup\{\snull\})\) does not hold. Then we have \(
  \exists \sigma \) and \(Q\) s.t. \( \langle P_1, C\cup\{\snull\}
  \rangle \xlongrightarrow{\sigma} \langle Q, C' \rangle \) and
  \(\sharp_{m}(\sigma) - \sharp_{f}(\sigma) > n\).

  From the definition of that \(OK_n(\Sirx(P_1, P_2), C)\) holds, we
  have if \( \langle \Sirx(P_1, P_2), C \rangle \xlongrightarrow{\snull}
  \langle P_1, C\cup\{\snull\} \rangle \xlongrightarrow{\sigma}
  \langle Q, C' \rangle \), then \(\sharp_m(\sigma) - \sharp_f(\sigma)
  \le n \). Therefore, we
  get the contradiction and \(\OK_n(P_1, C\cup\{\snull\})\) holds.

\item Case \( P = \Sirx(P_1,P_2) \) and \( \frac{ \snull,\snnull \notin C
  \andalso \scon\Sirx \in C} { \langle \Sirx(P_1, P_2), C \rangle
  \xlongrightarrow{\snnull} \langle P_2, C\cup\{\snnull\} \rangle } \)

  Similar to the above.
  
\item Case \( P = \scon\Sirx P' \) and \( \langle \scon\Sirx P', C \rangle
  \rightarrow \langle P';\Endconst, C\cup{\scon\Sirx} \rangle  \)

  We need to prove \(\OK_n(P';\Endconst, C\cup{\scon\Sirx})\).  Assume
  that \(\OK_n(P';\Endconst, C\cup{\scon\Sirx})\) does not hold. Then,
  we have \( \exists \sigma \) and \(Q\) s.t. \( \langle
  P';\Endconst, C\cup{\scon\Sirx} \rangle \xlongrightarrow{\sigma}
  \langle Q, C' \rangle \) and \(\sharp_{m}(\sigma) -
  \sharp_{f}(\sigma) > n\).

  From the definition of that \(OK_n(\scon\Sirx P', C)\) holds, we
  have if \( \langle \scon\Sirx P', C \rangle \rightarrow \langle
  P;\Endconst, C\cup{\scon\Sirx} \rangle \xlongrightarrow{\sigma}
  \langle Q, C' \rangle \), then \(\sharp_m(\sigma) -
  \sharp_f(\sigma) \le n \), which is in
  contradiction to the assumption.  Therefore, \(\OK_n(P';\Endconst, C\cup{\scon\Sirx})\)
  holds.

\item Case \( P = \mu\alpha.P' \) and \( \langle \mu\alpha.P', C
  \rangle \rightarrow \langle [\mu\alpha.P'/\alpha]P', C \rangle \)

  We need to prove \(\OK_n([\mu\alpha.P'/\alpha]P', C) \).  Assume
  that \(\OK_n( [\mu\alpha.P'/\alpha]P', C) \) does not hold. Then, we
  have \( \exists \sigma \) and \(Q\) s.t. \( \langle
  [\mu\alpha.P'/\alpha]P', C \rangle \xlongrightarrow{\sigma} \langle
  Q, C' \rangle \) and \(\sharp_{m}(\sigma) -
  \sharp_{f}(\sigma) > n\).

  From the definition of that \(OK_n(\mu\alpha.P', C)\) holds, we have
  if \( \langle \mu\alpha.P', C \rangle \rightarrow \langle
  [\mu\alpha.P'/\alpha]P', C \rangle \xlongrightarrow{\sigma} \langle
  Q, C' \rangle \), then \(\sharp_m(\sigma) -
  \sharp_f(\sigma) \le n \), which is a contradiction. Therefore,
  \(OK([\mu\alpha.P'/\alpha]P', C) \) holds.

%% \item Case \( P = P_1 + P_2 \) and \(  \langle P_1 + P_2, F \rangle
%%   \rightarrow \langle P_1, F  \rangle  \)

%%   We need to prove \(\OK_n(P_1, F) \).  Assume that \(\OK_n(P_1, F) \)
%%   does not hold. Then, we have (1) \( \exists \sigma \) and \(Q\)
%%   s.t. \( \langle P_1, F \rangle \xlongrightarrow{\sigma} \langle Q,
%%   F' \rangle \) and \(\sharp_{m}(\sigma) -
%%   \sharp_{f}(\sigma) > n\) or (2) \( OK(F)\) does not hold.

%%   From the definition of that \(OK_n(P_1 + P_2, F)\) holds, we have
%%   (1) if \( \langle P_1 + P_2, F \rangle \rightarrow \langle P_1, F
%%   \rangle \xlongrightarrow{\sigma} \langle Q, F' \rangle \), then \(\sharp_m(\sigma) - \sharp_f(\sigma) \le n \) and
%%   (2) \(OK(F)\) holds, which are in contradiction to assumption
%%   . Therefore, \(OK(P_1, F) \) holds.

\item Case \( P = P_1;P_2 \) and \( \frac{ \langle P_1, C \rangle
  \xLongrightarrow{\rho} \langle P_1', C' \rangle} { \langle P_1;P_2,
  C \rangle \xLongrightarrow{\rho} \langle P_1';P_2, C' \rangle } \)

  We need to prove \(\OK_{n'}(P_1';P_2, C) \), where \(n'\) is
  determined by 
  \[
   n'=\left\{
   \begin{array}{ll}
     n + 1 & \rho = \Free\\
     n - 1 & \rho = \Malloc\\
     n & \mbox{Otherwise.}
   \end{array}
   \right.
   \]

  Assume that \(\OK_{n'}(P_1';P_2, C') \) does not hold. Then, we have
  \( \exists \sigma \), \(Q\) and \(C''\) s.t. \( \langle P_1';P_2, C
  \rangle \xlongrightarrow{\sigma} \langle Q, C'' \rangle \) and
  \(\sharp_{m}(\sigma) - \sharp_{f}(\sigma) > n'\).

  From the definition of that \(OK_n(P_1;P_2, C)\) holds, we have if
  \( \langle P_1;P_2, C \rangle \xLongrightarrow{\rho} \langle
  P_1';P_2, C' \rangle \xlongrightarrow{\sigma} \langle Q, C'' \rangle
  \), then \(\sharp_m(\rho\sigma) - \sharp_f(\rho\sigma) \le n \).

  Then we get \( n' + \sharp_m(\rho) - \sharp_f(\rho) <
  \sharp_m(\rho) + \sharp_m(\sigma) - \sharp_f(\rho) -
  \sharp_f(\sigma) \le n\). For any \(\rho\), the \( n' +
  \sharp_m(\rho) - \sharp_f(\rho) = n\), therefore we get a
  contradiction. Therefore, \(OK_{n'}(P_1;P_2, F')\) holds.

\end{itemize}
\end{proof}

\begin{lemma}
\label{lem:consistency}
If \(consistency(H, R, C)\) and \(\langle H, R, s, n, C \rangle
\xlongrightarrow{\rho}_D \langle H', R', s', n', C'\rangle \), then
\(consistency(H', R', C')\).
\end{lemma}

    %% \(\textcircled{1}\)
\begin{proof}
  By induction on \(\langle H, R, s, n, C \rangle
  \xlongrightarrow{\rho}_D \langle H', R', s', n', C'\rangle \)
 \begin{itemize}
    
  \item Case: \(\langle H, R, \scon(*y) s, n, C \rangle \rightarrow_D
    \langle H, R, s;\EndConst(*y), n', C \cup {\scon(*y)} \rangle \).

    We need to prove \(consistency(H, R, C \cup {\scon(*y)})\). Form
    assumption \(consistency(H, R, C)\), we have (1) \(\forall x\).if
    \(\snull \in C\), then \(\scon\Sirx \in C\) and if \(H(R(x))\) is
    defined then \(H(R(x)) = null\) and (2) \(\forall x\).if
    \(\snnull \in C\), then \(\scon\Sirx \in C\) and if \(H(R(x))\) is
    defined then \(H(R(x)) \ne null\).

    To prove \(consistency(H, R, C \cup {\scon(*y)})\), we chose \(z\)
    arbitrarily. (3) Assuming \(\NULL(*z) \in C\cup{\scon(*y)}\). This
    implies \(\NULL(*z) \in C\). By using (1), we have \(\scon(*z) \in
    C\), and this implies \(\scon(*z) \in C \cup
    \scon(*y)\). Assuming \(H(R(z))\) is defined, then \(H(R(z)) =
    null\) from (1). (4) Assuming \(\neg\NULL(*z) \in C\cup{\scon(*y)}\). This
    implies \(\neg\NULL(*z) \in C\). By using (2), we have \(\scon(*z) \in
    C\). This implies \(\scon(*z) \in C \cup
    \scon(*y)\). Assuming \(H(R(z))\) is defined, then \(H(R(z)) \ne
    null\) from (2). 
    
    Therefore, \(consistency(H, R, C \cup {\scon(*y)})\) holds.

\item Case: \(\langle H, R, \EndConst(*y), n, C \rangle \rightarrow_D
    \langle H, R, skip, n, C'\rangle \) where \(C' = filter(C, *y)\).

    We need to prove \(consistency(H, R, C')\) where \(C' = filter(C,
    *y)\). From assumption \(consistency(H, R, C)\), we have (1)
    \(\forall x\).if \(\snull \in C\), then \(\scon\Sirx \in C\) and
    if \(H(R(x))\) is defined then \(H(R(x)) = null\) and (2)
    \(\forall x\).if \(\snnull \in C\), then \(\scon\Sirx \in C\) and
    if \(H(R(x))\) is defined then \(H(R(x)) \ne null\).

    To prove \(consistency(H, R, C')\), we chose \(z\)
    arbitrarily. From the definition of function \(filter(C, *y)\), we
    know (3) if \(\scon(*y) \in (C - \scon(*y))\) then we have \(C' =
    C - \scon(*y)\), otherwise we have \(C' = (C -
    \scon(*y))\backslash\{\NULL(*y), \neg\NULL(*y)\}\). From (3) we have \(C'
    \subseteq C\). (4) Assuming \(\NULL(*z) \in C'\), this implies
    \(\NULL(*z) \in C\). From (1) we have \(\scon(*z) \in C\). Now we
    want to get \(\scon(*z) \in C'\). We should consider two cases:
    \(z \ne y\) and \(z = y\). If \(z \ne y\) then we have \(\scon(*z)
    \in C'\) from (3); if \(z = y\), and because \(\NULL(*z) \in C'\),
    then we have \(\scon(*z) \in C'\). Assuming \(H(R(z))\) is
    defined, then we have \(H(R(z)) = null\) from (1). (5) Assuming
    \(\neg\NULL(*z) \in C'\). The similar to (4).

    Therefore, \(consistency(H, R, C')\) holds.

  \item Case: \(\langle H, R, \Free(y), n, C \rangle \xlongrightarrow{\Free}_D
    \langle H\backslash R(y), R, skip, n+1, C  \rangle \).

    We need to prove \(consistency(H\backslash R(y), R, C)\). From
    assumption \(consistency(H, R, C)\), we have (1) \(\forall x\).if
    \(\snull \in C\), then \(\scon\Sirx \in C\) and if \(H(R(x))\) is
    defined then \(H(R(x)) = null\) and (2) \(\forall x\).if
    \(\snnull \in C\), then \(\scon\Sirx \in C\) and if \(H(R(x))\) is
    defined then \(H(R(x)) \ne null\).

    To prove \(consistency(H\backslash R(y), R, C)\), we chose \(z\)
    arbitrarily. (3) Assuming \(\NULL(*z) \in C\). By using (1), we
    have \(\scon(*z) \in C\). Assuming \(H(R(z))\) is defined, we have
    \(H(R(z)) = null\) from (1). We know that \(R(y)\) has been
    deallocated from \(H\), so if \( z = y \) then \((H\backslash
    R(y))(R(z))\) is not defined, otherwise \((H\backslash R(y))(R(z))\)
    is defined and \((H\backslash R(y))(R(z)) = H(R(z)) = null\). (4)
    Assuming \(\NULL(*z) \in C\), By using (2), we have \(\scon(*z)
    \in C\). Assuming \(H(R(z))\) is defined, we have \(H(R(z)) \ne
    null\) from (2). We know that \(y\) has been deallocated from
    \(H\), so if \( z = y \) then \((H\backslash R(y))(R(z))\) is not
    defined, otherwise \((H\backslash R(y))(R(z))\) is defined and
    \((H\backslash R(y))(R(z)) = H(R(z)) \ne null\).

    Therefore, \(consistency(H\backslash R(y), R, C)\) holds.
        
\item Case: \(\langle H, R, \LET y = \Malloc \; \IN s, n, C \rangle
  \xlongrightarrow{\Malloc}_D \langle H\set{l \mapsto v}, R\set{x'
    \mapsto l}, [x'/y]s, n', C \rangle \) where \(x' \notin
  \DOM(H)\cup\DOM(R)\cup fv(C) \)

    We need to prove \(consistency(H\set{l \mapsto v}, R\set{x'
      \mapsto l}, C )\). From assumption \(consistency(H, R, C)\), we
    have (1) \(\forall x\).if \(\snull \in C\), then \(\scon\Sirx \in
    C\) and if \(H(R(x))\) is defined then \(H(R(x)) = null\) and (2)
    \(\forall x\).if \(\snnull \in C\), then \(\scon\Sirx \in C\) and
    if \(H(R(x))\) is defined then \(H(R(x)) \ne null\).

    To prove \(consistency(H\set{l \mapsto v}, R\set{x' \mapsto l}, C
    )\), we chose \(z\) arbitrarily. (3) Assuming \(\NULL(*z) \in
    C\). From (1) we have \(\scon(*z) \in C\). Assuming \(H(R(z))\) is
    defined, we have \(H(R(z)) = null \) from (1). We have \(x' \notin
    \DOM(H)\cup\DOM(R)\cup fv(C) \), so \(z \ne x'\). Therefore we get
    \(H\set{l \mapsto v}(R\set{x' \mapsto l}z) = H(R(z)) = null\). (4)
    Assuming \(\neg\NULL(*z) \in C\). similar to (3).
    
    Therefore, \(consistency(H\set{l \mapsto v}, R\set{x' \mapsto l},
    C )\) holds.

\item Case: \(\langle H, R, skip;s, n, C \rangle \rightarrow_D
    \langle H, R, s, n', C \rangle \).

    Obviously, \(consistency(H, R, C) \) holds form assumption.

\item Case: \(\langle H\set{R(w) \mapsto v}, R, *w \leftarrow y, n, C
  \rangle \rightarrow_D \langle H\set{R(w) \mapsto R(y)}, R, skip, n, C
  \rangle \) where \( \forall z. R(w) = R(z) \Rightarrow \scon(*z)
  \notin C \)

    We need to prove \(consistency(H\set{R(w) \mapsto R(y)}, R, C)
    \). From assumption \(consistency(H, R, C)\), we have (1)
    \(\forall x\).if \(\snull \in C\), then \(\scon\Sirx \in C\) and
    if \(H\set{R(w)\mapsto v}(R(x))\) is defined then \(H\set{R(w) \mapsto
      v}(R(x)) = null\) and (2) \(\forall x\).if \(\snnull \in C\),
    then \(\scon\Sirx \in C\) and if \(H\set{R(w)\mapsto v}(R(x))\) is
    defined then \(H\set{R(w) \mapsto v}(R(x)) \ne null\).

    To prove \(consistency(H\set{R(w) \mapsto R(y)}, R, C) \), we
    chose \(m\) arbitrarily. (3) Assuming \(\NULL(*m) \in C\). By
    using (1), we have \(\scon(*m) \in C\). Because we know \( \forall
    z. R(w) = R(z) \Rightarrow \scon(*z) \notin C \), we have \(m \ne
    w\). Then assuming \(H\set{R(w)\mapsto v}(R(m))\) is defined, we
    have \(H\set{R(w)\mapsto v}(R(m)) = null\) from (1). Then we
    get \(H\set{R(w)\mapsto R(y)}(R(m)) = H\set{R(w) \mapsto v}(R(m))
    = null\) . (4) Assuming \(\neg\NULL(*m) \in C\). Similar to (3).
    
    Therefore, \(consistency(H\set{R(w) \mapsto R(y)}, R, C)\) holds.

\item Case: \(\langle H, R, \LET z = y \; \IN s, n, C
  \rangle \rightarrow_D \langle H, R\set{z' \mapsto R(y)}, [z'/z]s, n, C
  \rangle \) where \(z' \notin \DOM(H)\cup\DOM(R)\cup fv(C) \)
  
  We need to prove \(consistency(H, R\set{z'\mapsto R(y)}, C) \). From
  assumption \(consistency(H, R, C)\), we have (1) \(\forall x\).if
  \(\snull \in C\), then \(\scon\Sirx \in C\) and if \(H(R(x))\) is
  defined then \(H(R(x)) = null\) and (2) \(\forall x\).if \(\snnull
  \in C\), then \(\scon\Sirx \in C\) and if \(H(R(x))\) is defined
  then \(H(R(x)) \ne null\).

  To prove \(consistency(H, R\set{z'\mapsto R(y)}, C \), we chose
  \(m\) arbitrarily. (3) Assuming \(\NULL(*m) \in C\). By using (1),
  we have \(\scon(*m) \in C\). Then assuming \(H(R(m))\) is defined,
  we have \(H(R(m)) = null\) from (1). Because we have \(z' \notin
  \DOM(H)\cup\DOM(R)\cup fv(C) \), we have \(m \ne z'\), then we have
  \( H(R\set{z' \mapsto R(y)}(m)) = H(R(m)) = null\). (4) Assuming
  \(\neg\NULL(*m) \in C\). By using (2), we have \(\scon(*m) \in C\). Then
  assuming \(H(R(m))\) is defined, we have \(H(R(m)) \ne null\) from
  (2). Because we have \(z' \notin \DOM(H)\cup\DOM(R)\cup fv(C) \), we
  have \(m \ne z'\), then we have \( H(R\set{z' \mapsto R(y)}(m)) =
  H(R(m)) \ne null\).
  
  Therefore, \(consistency(H, R\set{z' \mapsto R(y)}, C)\) holds.

\item Case: \(\langle H, R, \LET z = *y \; \IN s, n, C
  \rangle \rightarrow_D \langle H, R\set{z' \mapsto H(R(y))}, [z'/z]s, n, C
  \rangle \) where \(R(y) \notin \DOM(H)\) and \(z' \notin \DOM(H)\cup\DOM(R)\cup fv(C) \)

  Similar to above.

\item Case: \(\langle H, R, \LET z = \NULL \; \IN s, n, C
  \rangle \rightarrow _D \langle H, R\set{z' \mapsto \NULL}, [z'/z]s, n, C
  \rangle \) where \(z' \notin \DOM(H)\cup\DOM(R)\cup fv(C) \)

  Similar to above.

\item Case: \(\langle H, R, \IFNULL(*y) \ \THEN s_1\ \ELSE\ s_2, n, C
  \rangle \xlongrightarrow{\NULL(*y)}_D \langle H, R, s_1, n, C \rangle \)
  where \( H(R(y)) = null \) and \(\scon(*y) \notin C\)

  Obviously, \(consistency(H, R, C) \) holds from assumption.

\item Case: \(\langle H, R, \IFNULL(*y) \ \THEN s_1\ \ELSE\ s_2, n, C
  \rangle \xlongrightarrow{\neg\NULL(*y)}_D \langle H, R, s_2, n, C \rangle \)
  where \( H(R(y)) \ne null \) and \(\scon(*y) \notin C\)

 Obviously, \(consistency(H, R, C) \) holds from assumption.

\item Case: \(\langle H, R, \IFNULL(*y) \ \THEN s_1\ \ELSE\ s_2, n, C
  \rangle \xlongrightarrow{\NULL(*y)}_D \langle H, R, s_1, n, C \cup{\NULL(*y)}
  \rangle \) where \( H(R(y)) =  null \) and \(\scon(*y) \in C\)
  
  We need to prove \(consistency(H, R, C\cup{\NULL(*y)}) \). From
  assumption \(consistency(H, R, C)\), we have (1) \(\forall x\).if
  \(\snull \in C\), then \(\scon\Sirx \in C\) and if \(H(R(x))\) is
  defined then \(H(R(x)) = null\) and (2) \(\forall x\).if \(\snnull
  \in C\), then \(\scon\Sirx \in C\) and if \(H(R(x))\) is defined
  then \(H(R(x)) \ne null\).

  To prove \(consistency(H, R, C\cup{\NULL(*y)}) \), we chose \(z\)
  arbitrarily. (3) Assuming \(\NULL(*z) \in C\cup\NULL(*y)\). This
  implies \(\NULL(*z) \in C\). By using (1), we have \(\scon(*z) \in
  C\). This implies \(\scon(*z) \in C\cup\NULL(*y)\). Assuming
  \(H(R(z))\) is defined, then we have \(H(R(z)) = null\) from
  (1). (4) Assuming \(\neg\NULL(*z) \in C\cup\NULL(*y)\). This implies
  \(\neg\NULL(*z) \in C\). By using (2), we have \(\scon(*z) \in C\). This
  implies \(\scon(*z) \in C\cup\NULL(*y)\). Assuming \(H(R(z))\) is
  defined, then we have \(H(R(z)) \ne null\) from (2). 

  Therefore, \(consistency(H, R, C\cup{\NULL(*y)})\) holds.

\item Case: \(\langle H, R, \IFNULL(*y) \ \THEN s_1\ \ELSE\ s_2, n, C
  \rangle \xlongrightarrow{\neg\NULL(*y)}_D \langle H, R, s_2, n, C \cup{\neg\NULL(*y)}
  \rangle \) where \( H(R(y)) \ne  null \) and \(\scon(*y) \in C\)

  Similar to above.  

\item Case: \(\langle H, R, f(\vec{x}), n, C \rangle \rightarrow_D
  \langle H, R, [\vec{x}/\vec{y}]s, n, C \rangle \) where \( D(f) = (\vec{y})s\)

  Obviously, \(consistency(H, R, C) \) holds from assumption.

\item Case: \(\langle H, R, s_1;s_2, n, C \rangle
  \xlongrightarrow{\rho}_{D} \langle H', R', s_1';s_2, n', C' \rangle
  \) if \(\langle H, R, s_1, n, C \rangle \xlongrightarrow{\rho}_{D}
  \langle H', R', s_1', n', C' \rangle\)

  We need to prove \(consistency(H', R', C')\). We have the assumption
  \(consistency(H, R, C)\). \(consistency(H', R', C')\) holds
  obviously by induction hypothesis.
  
 \end{itemize}
\end{proof}


\begin{pfof}{Lemma~\ref{lem:preservation}}
By induction on the derivation of \(\langle H, R, s, n, C \rangle
\xlongrightarrow{\rho} \langle H' ,R' ,s', n', C' \rangle\).

\begin{itemize}

\item Case: \( \langle H, R, \scon\Sirx s, n, C \rangle
  \rightarrow \langle H, R, s;\Endconst, n, C\cup
  \{\scon\Sirx\} \rangle \)

  From the assumption \( \Theta \vdash \langle H, R, \scon\Sirx s, n,
  C \rangle : \langle P, C \rangle\), we have \( \exists \Gamma\) s.t.
  \(\Theta; \Gamma \vdash \scon\Sirx s: P \), \( OK_n(P, C) \),
  \(consistency(H, R, C)\) and \(\Gamma \subseteq \DOM(R)\). From the
  inversion of typing rules, we get \( \Theta; \Gamma \vdash s:P'' \)
  and \( \scon\Sirx P'' \le P \) for some \( P'' \). By subtyping, we
  have \( P'';\Endconst \le Q \) and \( \langle P, C \rangle
  \Longrightarrow \langle Q, C\cup \{\scon\Sirx\} \rangle \) for some
  \( Q \).

  we need to find \(P'\) and \(C'\) s.t. \( \exists \Gamma' \Theta;
  \Gamma' \vdash s;\Endconst:P'\), \( OK_n(P', C')\), \( \langle P, C'
  \rangle \Longrightarrow \langle P', C' \rangle \) and
  \(consistency(H, R, C')\). Taking \( Q \) as \( P'\), \( C \cup
  \{\scon\Sirx\} \) as \(C'\) and \(\Gamma\) as \(\Gamma'\). Therefore \(
  \langle P, C \rangle \rightarrow \langle P', C' \rangle\) and
  \(\Gamma \subseteq \DOM(R)\) hold, and then \( OK_n(P', C')\) and
  \(consistency(H, R, C')\) hold from Lemma~\ref{lem:okPreserved} and
  Lemma~\ref{lem:consistency}. From \( \Theta; \Gamma \vdash
  s;\Endconst:P'';\Endconst \), \( P'';\Endconst \le Q \) and
  \rn{T-Sub}, \( \Theta; \Gamma \vdash s;\Endconst:P'\) holds.

\item Case: \( \langle H, R, \Endconst, n, C \rangle \rightarrow
  \langle H, R, \SKIP, n, C' \rangle \) where \(C'\) = \(filter(C,
  *x)\)

   From the assumption \( \Theta \vdash \langle H, R, \Endconst, n, C
   \rangle : \langle P, C \rangle\), we have \(\exists \Gamma\)
   s.t. \( \Theta; \Gamma \vdash \Endconst \COL P\), \( OK_n(P, C) \)
   \(consistency(H, R, C)\) and \(\Gamma \subseteq \DOM(R)\). From the
   inversion of typing rules, we get \( \Theta; \Gamma \vdash
   \Endconst:\Endconst \) and \( \Endconst \le P \). By subtyping , we
   get \( 0 \le Q \) and \( \langle P, C \rangle \rightarrow \langle
   Q, C \rangle\) for some \( Q \).

   we need to find \(P'\) and \(C'\) s.t. \(\exists \Gamma'\) s.t. \(
   \Theta; \Gamma' \vdash
  \SKIP:P'\), \( OK_n(P', C')\), \( \langle P, C \rangle
  \Longrightarrow P', C' \rangle \), \(consistency(H, R, C')\) and
  \(\Gamma' \subseteq \DOM(R)\). Taking \( Q \) as \( P'\), \(C\) as
  \(C'\) and \(\Gamma\) as \(\Gamma'\), then \( \langle P, C \rangle
  \rightarrow \langle P', C' \rangle\) and \(\Gamma' \subseteq
  \DOM(R)\) hold, and then \( OK_n(P', C')\) and \(consistency(H, R,
  C')\) hold from Lemma~\ref{lem:okPreserved} and
  Lemma~\ref{lem:consistency} . From \rn{T-Skip}, \rn{T-Sub} and \( 0
  \le Q\), then \( \Theta; \Gamma \vdash \SKIP:P'\) holds.

\item Case: \(\langle H, R, \FREE, n, C\rangle \xlongrightarrow{\Free}
  \langle H', R, \SKIP, n + 1, C \rangle \)

  From the assumption \( \Theta \vdash \langle H, R, \FREE, n, C
  \rangle : \langle P, C \rangle\), we have \(\exists \Gamma\)
  s.t. \(\OK_n(P, C)\), \(consistency(H, R, C)\), \(\Theta; \Gamma
  \vdash \Free(x) \COL P\) and \(\Gamma \subseteq \DOM(R)\).  From
  inversion of the typing rules, we have \(\Theta; \Gamma \vdash
  \Free(x) \COL \Free\) and \(\Free \le P\). By the subtyping, we have
  \( \langle P, F \rangle \xLongrightarrow{\Free} \langle Q, C
  \rangle\) and \(\TSKIP \le Q \) for some \(Q\).

  We need to find \(P'\) and \(C'\) such that \(\exists \Gamma'\)
  s.t. \( \langle P, C \rangle \xLongrightarrow{\Free} \langle P', C'
  \rangle \), \(\Theta; \Gamma' \vdash \SKIP \COL P'\),
  \(\OK_{n+1}(P', C')\), \(consistency(H, R, C')\) and \(\Gamma'
  \subseteq \DOM(R)\). Take \(Q\) as \(P'\), \(C\) as \(C'\) and
  \(\Gamma\) as \(\Gamma'\).  Then, \( \langle P, C \rangle
  \xLongrightarrow{\Free} \langle P', C' \rangle \) and \(\Gamma'
  \subseteq \DOM(R)\) hold, and \(OK_{n+1}(P', C')\) and
  \(consistency(H', R, C)\) hold from Lemma~\ref{lem:okPreserved} and
  Lemma~\ref{lem:consistency}.  We also have \(\Theta; \Gamma
  \vdash \SKIP \COL P'\) from \rn{T-Skip}, \(\TSKIP \le Q\) and
  \rn{T-Sub}.

\item Case: \( \langle H, R, \LET x = \MALLOC \IN s, n, C\rangle
  \xlongrightarrow{\Malloc} \langle H\set{l \mapsto v}, R\set{x'
    \mapsto l}, [x'/x]s, n - 1, C \rangle \) where \(l \notin
  \DOM(H)\) and \(x' \notin \DOM(H)\cup\DOM(R)\cup fv(C)\)

  From the assumption \( \Theta \vdash \langle H, R, \LET x = \MALLOC
  \IN s, n, C \rangle : \langle P, C \rangle\), we have \(\Theta;
  \Gamma \vdash \LET x = \MALLOC \IN s \COL P\), \(\OK_{n}(P, C)\),
  \(consistency(H, R, C)\) and \(\Gamma \subseteq \DOM(R)\). By the
  inversion of typing rules, we have \(\Theta; \Gamma, x \vdash s :
  P'' \) and \( \Malloc; (x)P'' \le P \) for some \(P''\). By
  subtyping, we get \( \langle P, C \rangle \xLongrightarrow{\Malloc}
  \langle Q, C \rangle \) and \( (x)P'' \le Q\) for some \(Q\).

  We need to find \(P'\) and \(C'\) such that \(\exists \Gamma'\)
  s.t. \(\Theta; \Gamma' \vdash [x'/x]s\COL P'\), \( \langle P, C
  \rangle \xLongrightarrow{\Malloc} \langle P', C' \rangle\),
  \(consistency(H', R', C')\), \(OK_{n-1}(P', C')\) and \(\Gamma'
  \subseteq \DOM(R\set{x' \mapsto l})\). Take \(Q\) as \(P'\), \(C\)
  as \(C'\) and \(\Gamma,x'\) as \(\Gamma'\).  Then \( \langle P, C
  \rangle \xLongrightarrow{\Malloc} \langle P', C' \rangle\) and
  \(\Gamma' \subseteq \DOM(R\set{x' \mapsto l})\) hold, and then
  \(OK_{n-1}(P', C')\) and \(consistency(H\set{l\mapsto v}, R\set{x'
    \mapsto l}, C)\) hold by Lemma~\ref{lem:okPreserved} and
  Lemma~\ref{lem:consistency}. From \(\Theta; \Gamma, x \vdash s :
  P''\) and \( \Malloc;(x)P'' \le P\), by replacing \(x\) with
  \(x''\), we have \(\Theta; \Gamma, x'' \vdash [x''/x]s :
         [x''/x]P''\) and \( \Malloc;[x''/x]P'' \le P\), and then by the
         definition of subtyping we have \([x''/x]P'' \le Q'\) for
         some \(Q'\). Therefore, we get \(\Theta; \Gamma, x'' \vdash
         [x''/x]s : Q'\). Take \(x''\) as \(x'\) and \(Q'\) as \(P'\),
         then \(\Theta;\Gamma, x' \vdash [x'/x]s\COL P'\) holds.
      
\item Case: \( \langle H, R, \SKIP;s, n, C \rangle \rightarrow \langle
  H, R, s, n, C \rangle \)

  From the assumption \( \Theta; \Gamma \vdash \langle H, R, \SKIP;s,
  n, C \rangle : \langle P, C \rangle\), we have \(\Theta;\Gamma
  \vdash \SKIP;s\COL P\), \(\OK_{n}(P, C)\) and \(consistency(H, R,
  C)\). From the inversion of the typing rules, we get \(\Theta;
  \Gamma \vdash s\COL P''\) and \(0;P'' \le P\). From the definition
  of subtyping, we have \( \langle P, C \rangle \Longrightarrow
  \langle Q, C \rangle\) and \(P'' \le Q\) for some \(Q\).

  We need to find \(P'\) and \(C'\) such that \(\Theta; \Gamma \vdash
  s : P'\) and \(\langle P, C \rangle \rightarrow \langle P', C'
  \rangle\) and \(OK_n(P', C')\). Take \(Q\) as \(P'\) and \(C\) as
  \(C'\). Then \(\langle P, C\rangle \Longrightarrow \langle P', C'
  \rangle\) holds, and then \(OK_n(P', C')\) and \(consistency(H, R,
  C')\) hold. We also have \(\Theta;\Gamma \vdash s\COL P'\) from
  \rn{T-Sub}, \(\Gamma \vdash s\COL P''\) and \(P'' \le Q\).

\item Case: \( \langle H, R, *x \leftarrow y , n, C\rangle \rightarrow
  \langle H', R, \SKIP, n, C\rangle \)

  From the assumption \( \Theta; \Gamma \vdash \langle H, R, *x
  \leftarrow y, n, C \rangle : \langle P, C \rangle\), we have
  \(\Theta; \Gamma \vdash *x \leftarrow y : P\), \(\OK_{n}(P, C)\) and
  \(consistency(H, R, C)\). From the inversion of typing rules, we
  have \(0 \le P\).

  We need to find \(P'\) and \(C'\) such that \(\Theta; \Gamma
  \vdash \SKIP: P'\), \( \langle P, C \rangle \Longrightarrow \langle
  P', C' \rangle \) and \(\OK_n(P', C')\). Take \(P\) as \(P'\) and
  \(C\) as \(C'\). Then \( \langle P, C\rangle \Longrightarrow \langle
  P', C'\rangle\) holds, and then \(\OK_n(P', C')\) and
  \(consistency(H', R, C')\) hold from Lemma~\ref{lem:okPreserved} and
  Lemma~\ref{lem:consistency}. We also have \(\Theta; \Gamma
  \vdash \SKIP: P'\) from \rn{T-Skip}, \(0 \le P\) and \rn{T-Sub}.

\item Case: \( \langle H, R, \LET x = y\ \IN s , n, C \rangle
  \rightarrow \langle H, R', [x'/x]s, n, C \rangle \)

  From the assumption \( \Theta; \Gamma \vdash \langle H, R, \LET x =
  y\ \IN s, n, C \rangle : \langle P, C \rangle\), we have \(\Theta;
  \Gamma, y \vdash \LET x = y \ \IN s \COL P\), \(OK_{n}(P, C)\) and
  \(consistency(H, R, C)\). From the inversion of typing rules, we
  have \(\Theta; \Gamma, x,y \vdash s\COL P''\) and \( \LET x = y\;
  \IN P'' \le P\) for some \(P''\). By subtying, we have \( \langle P,
  C \rangle \rightarrow \langle Q, C \rangle \) and \([x'/x]P'' \le
  Q\) for some \(Q\).

  We need to find \(P'\) and \(C'\) such that \(\Theta; \Gamma,x',y
  \vdash [x'/x]s : P'\) , \( \langle P, C \rangle \rightarrow \langle
  P', C' \rangle\), \(\OK_n(P', C'\)) and \(consistency(H, R',
  C')\). Take \(Q\) as \(P'\) and \(C\) as \(C'\). Then \( \langle P,C
  \rangle \Longrightarrow \langle P', C' \rangle\) and \(\OK_n(P',
  C')\) hold. From \(\Theta; \Gamma, x,y \vdash s\COL P''\) and \(
  \LET x = y\; \IN P'' \le P\), we have \(\Theta; \Gamma, x'',y \vdash
       [x''/x]s : [x''/x]P''\) and \( \LET x'' = y\; \IN [x''/x]P''
       \le P\), and then by subtying we have \([x''/x]P'' \le Q'\) for
       some \(Q'\). Therefore, we have \(\Theta; \Gamma, x'',y \vdash
       [x''/x]s : Q'\). Take \(x''\) as \(x'\) and \(Q'\) as \(P'\),
       then \(\Theta; \Gamma,x',y \vdash [x'/x]s : P'\) holds.
  
\item Case: \( \langle H, R, \LET x = \NULL \ \IN \ s, n\rangle
  \rightarrow \langle H, R', [x'/x]s, n \rangle \)

  Similar to the above.

\item Case: \( \langle H, R, \LET x = *y \ \IN \ s, n\rangle
  \rightarrow \langle H, R', [x'/x]s, n\rangle \)

  Similar to the above.

\item Case: \(\langle H, R, \IFNULL \Sirx \ \THEN s_{1} \ \ELSE
  \ s_{2}, n, C\rangle \xlongrightarrow{\snull} \langle H, R, s_{1}, n, C \rangle\)
  if \(H(R(x)) = \NULL\) and \(\scon\Sirx \notin C\)

  From assumption \( \Theta; \Gamma \vdash \langle H, R, \IFNULL\Sirx
  \ \THEN s_{1} \ \ELSE \ s_{2}, n, C \rangle : \langle P, C
  \rangle\), we have \(\Theta; \Gamma \vdash \IFNULL\Sirx \ \THEN
  s_{1} \ \ELSE \ s_{2} \COL P \), \(OK_n(P, C)\) and \(consistency(H,
  R, C)\). From the inversion of typing rules, we have \(\Theta;
  \Gamma \vdash s_{1} \COL P_1\), \(\Theta; \Gamma \vdash s_{2} \COL
  P_2\) and \((*x)(P_1, P_2) \le P\). According to the rule
  Tr-NotConst1 and \(\scon\Sirx \notin C\), we have \(\langle
  (*x)(P_1, P_2) \rangle \xlongrightarrow{\snull} \langle P_1,
  C\rangle \), and then by definition of subtyping, we get \(\langle
  P, C \rangle \xLongrightarrow{\snull} \langle Q, C \rangle \) and
  \(P_1 \le Q\) for some \(Q\).

  We need to find \(P'\) and \(C'\) such that \(\Theta;\Gamma \vdash
  s_1\COL P'\), \( \langle P, C \rangle \xLongrightarrow{\snull}
  \langle P', C' \rangle\) and \(\OK_n(P', C'\)). Take \(Q\) as \(P'\)
  and \(C\) as \(C'\). Then \( \langle P,C \rangle
  \xLongrightarrow{\snull} \langle P', C' \rangle\) and \(\OK_n(P',
  C')\) hold.  We also have \(\Theta; \Gamma \vdash s_1 \COL P'\) from
  \rn{T-Sub}, \(\Theta; \Gamma \vdash s_1 \COL P_1\) and \( P_1 \le
  Q\).

\item Case: \(\langle H, R, \IFNULL \Sirx \ \THEN s_{1} \ \ELSE
  \ s_{2}, n, C\rangle \xlongrightarrow{\snnull} \langle H, R, s_{1}, n, C \rangle\)
  if \(H(R(x)) \neq \NULL\) and \(\scon\Sirx \notin C\)

    Similar to the above.
  
\item Case: \(\langle H, R, \IFNULL \Sirx \ \THEN s_{1} \ \ELSE
  \ s_{2}, n, C\rangle \xlongrightarrow{\snull} \langle H, R, s_{1}, n, C'
  \rangle\) if \(H(R(x)) = \NULL\), \(\scon\Sirx \in C\) and \(C' = C
  \cup \{\snull\}\)

  From assumption \( \Theta; \Gamma \vdash \langle H, R, \IFNULL\Sirx
  \ \THEN s_{1} \ \ELSE \ s_{2}, n, C \rangle : \langle P, C
  \rangle\), we have \(\Theta; \Gamma \vdash \IFNULL\Sirx \ \THEN
  s_{1} \ \ELSE \ s_{2} \COL P \), \(OK_n(P, C)\) and \(consistency(H,
  R, C)\). From the inversion of typing rules, we have \(\Theta;
  \Gamma \vdash s_{1} \COL P_1\), \(\Theta; \Gamma \vdash s_{2} \COL
  P_2\) and \((*x)(P_1, P_2) \le P\). According to rule
  Tr-NNullNotIn1, \(\scon\Sirx \in C\) and \(C' = C \cup \snull\), we
  have \(\langle (*x)(P_1, P_2) \rangle \xlongrightarrow{\snull}
  \langle P_1, C \cup \snull \rangle \), and then by the definition of
  subtyping, we get \(\langle P, C \rangle \xLongrightarrow{\snull}
  \langle Q, C\cup \{\snull\} \rangle \) and \(P_1 \le Q\) for some
  \(Q\).
  
  We need to find \(P'\) and \(C'\) such that \(\Theta;\Gamma \vdash
  s_1 \COL P'\), \( \langle P, C \rangle \xLongrightarrow{\snull}
  \langle P', C' \rangle\), \(\OK_n(P', C'\)) and \(consistency(H, R,
  C')\). Take \(Q\) as \(P'\) and \(C\cup \{\snull\}\) as \(C'\). Then
  \( \langle P,C \rangle \xlongrightarrow{\snull} \langle P', c'
  \rangle\) holds, and then \(\OK_n(P', C')\) and \(consistency(H, R,
  C')\)hold by Lemma~\ref{lem:okPreserved} and
  Lemma~\ref{lem:consistency}.  We also have \(\Theta; \Gamma \vdash
  s_1 \COL P'\) from \rn{T-Sub}, \(\Theta; \Gamma \vdash s_1 \COL
  P_1\) and \( P_1 \le Q\).

\item Case: \(\langle H, R, \IFNULL \Sirx \ \THEN s_{1} \ \ELSE
    \ s_{2}, n, C\rangle \xlongrightarrow{\snnull} \langle H, R, s_{2}, n, C'
    \rangle\) if \(H(R(x)) \neq \NULL\), \(\scon\Sirx \in C\) and \(C'
    = C \cup \{\snnull\}\)

  Similar to the above proof.

\item Case: \(\langle H, R, s_1;s_2, n, C\rangle \rightarrow \langle
  H', R', s_1';s_2, n', C' \rangle \)

  From the assumption \(\Theta; \Gamma \vdash \langle H, R, s_1;s_2,
  n, C \rangle : \langle P, C \rangle\), we have \(\Theta; \Gamma
  \vdash s_1;s_2 : P\), \(OK_n(P, C)\) and \(consistency(H, R,
  C)\). By inversion of typing rules, we have \(\Theta; \Gamma \vdash
  s_1: P_1\), \(\Theta; \Gamma \vdash s_2: P_2\) and \(P_1;P_2 \le P\)
  for some \(P_1\) and \(P_2\).

  By IH on \( \langle H, R, s_1, n, C \rangle \) with derivation \(
  \langle H, R, s_1, n, C \rangle \xlongrightarrow{\rho} \langle H',
  R', s_1', n', C' \rangle\), we have \(\exists P_1',C_1'\)
  s.t. \(\Theta; \Gamma \vdash \langle H', R', s_1', n', C' \rangle :
  \langle P_1', C_1' \rangle\) and \( \langle P_1, C \rangle
  \xlongrightarrow{\rho} \langle P_1', C_1' \rangle\).

  By subtyping we have \( \langle P, C \rangle \xlongrightarrow{\rho}
  \langle Q, C_1' \rangle \) and \(P_1';P_2 \le Q\) for some \(Q\).

  We need to find \(P'\) and \(C'\) s.t. \( \langle P, C \rangle
  \xlongrightarrow{\rho} \langle P', C' \rangle \), \( OK_n(P', C')\)
  and \(\Theta; \Gamma \vdash s_1';s_2 : P' \rangle\).  Take \(Q\) as
  \(P'\) and \(C_1'\) as \(C'\), \( \langle P, C \rangle
  \xlongrightarrow{\rho} \langle P', C' \rangle \) and \( OK_n(P',
  C')\) hold. By T-Sub, \(\Theta; \Gamma \vdash s_1';s_2 : P_1';P_2\)
  and \(P_1';P_2 \le Q\), we have \(\Theta; \Gamma \vdash s_1';s_2 :
  P'\) holds.

\end{itemize}
\end{pfof}  

%% \begin{corollary}
%% \label{cor:preservation}
%% If $OK_{n}(P, F)$, $\Theta; \Gamma \vdash s : P$, \(\vdash D \COL
%% \Theta\), and $\langle H,R,s,n\rangle \xlongrightarrow{\sigma} \langle
%% H',R',s', n' \rangle$, then there exists $P'$ such that (1) $ \Theta;
%% \Gamma \vdash s' : P'$, (2) \( \langle P, F \rangle
%% \xLongrightarrow{\sigma} \langle P', F' \rangle\), and (3)
%% \(OK_{n'}(P', F')\).
%% \end{corollary}

We write \(\langle H, R, s, n, C \rangle \xlongrightarrow{\rho}\) if
there is a transition \(\xlongrightarrow{\rho}\) from \(\langle H, R,
s, n, C \rangle\).

\begin{lemma}
\label{lem:enabled}
If \(\Theta \vdash \langle H, R, s, n, C \rangle \COL \langle
P,C \rangle\) and \(\langle H, R, s, n, C \rangle
\xLongrightarrow{\rho}\) and \(\rho \in \set{\Malloc, \Free, \snull, \snnull}\), then
there exists \(P'\) and \(C'\) such that \( \langle P, C \rangle
\ \xLongrightarrow{\rho} \langle P', C'\rangle\).
\end{lemma}

\begin{proof}
Induction on the derivation of \(\Theta; \Gamma \vdash \langle H, R, s, n, C \rangle \COL \langle P, C \rangle\).
\end{proof}

\begin{pfof}{Lemma~\ref{lem:immediateSafety}}

By contradiction.  Assume \(\langle H, R, s, n, C \rangle
\xlongrightarrow{\rho} \OVERFLOW\). Then, \(n\) is \(0\) and \(\rho =
\Malloc \) from \rn{Sem-OutOfMem}.  From the assumption we have
\(\Theta;\Gamma \vdash s \COL P\) and \(\OK_0(P, C)\).  From
Lemma~\ref{lem:enabled}, there exists \(P'\) and \(C'\) such that \(
\langle P, C \rangle \xLongrightarrow{\Malloc} \langle P', C'
\rangle\).  However, this contradicts \(\OK_0(P, C)\).

\end{pfof}

\begin{pfof}{Theorem~\ref{thm1}}

We have \(\Theta;\emptyset \vdash s\COL P, \vdash D\COL \Theta\),
\(\OK_n(P, C)\) and  \(consistency(H, R, C)\).

Suppose that there exists \(\sigma\) such that \(\langle \emptyset,
\emptyset, s, n, C\rangle \xlongrightarrow{\sigma} \langle H', R', s',
n', C'\rangle \xlongrightarrow{\rho} \OVERFLOW\).  Then, \(n' = 0\)
and \(\rho = \Malloc \).  From Lemma~\ref{lem:preservation}, there
exists \(P'\) and \(C'\) such that \(\Theta; \Gamma' \vdash s' \COL
P'\), \( \langle P, C \rangle \xLongrightarrow{\sigma} \langle P', C'
\rangle \), \(\OK_0(P', C')\) and \(consistency(H', R', C')\). So if
\(\langle H', R', s', 0, C'\rangle \xlongrightarrow{\Malloc}\), it
will contradict the Lemma~\ref{lem:immediateSafety}.

\end{pfof}
